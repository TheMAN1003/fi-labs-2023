#include <iostream>
#include <bitset>

using std::cin, std::cout, std::vector, std::pair;

void L1(u_int64_t &x, u_int64_t &x0)
{
    u_int64_t l = ((x >> 6) & 1) ^ ((x >> 4) & 1) ^ ((x >> 1) & 1) ^ (x & 1);
    x0 = x & 1;
    x = (x>>1) ^ (l << 29);
}


void L2(u_int64_t &y, u_int64_t  &y0)
{
    u_int64_t l = ((y >> 3) & 1) ^ (y & 1);
    y0 = y & 1;
    y = (y >> 1) ^ (l << 30);
}

void L3(u_int64_t &s, u_int64_t &s0)
{
    u_int64_t l = ((s >> 3) & 1) ^ (s & 1);
    s0 = s & 1;
    s = (s >> 1) ^ (l << 31);
}

u_int64_t F(u_int64_t &x, u_int64_t& y, u_int64_t& s)
{
    return (s & x) ^ ((1 ^ s) & y);
}

//const int wt[256] = [0, 1, 1, 2, 1, 2, 2, 3, 1, 2, 2, 3, 2, 3, 3, 4,
//                     1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5,
//                     1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5,
//                     ]

const int wt8[256] = {0, 1, 1, 2, 1, 2, 2, 3, 1, 2, 2, 3, 2, 3, 3, 4, 1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5, 1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5, 2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5, 2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7, 1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5, 2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7, 2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7, 3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7, 4, 5, 5, 6, 5, 6, 6, 7, 5, 6, 6, 7, 6, 7, 7, 8};

u_int16_t R(vector<uint64_t> x, vector<uint64_t> z)
{
    vector<uint64_t> tmp(x.size());
    if(x.size() != z.size())
    {
        std::cout<<"prblem\n\n";
    }
    for(size_t i = 0; i < x.size(); ++i)
    {
        tmp[i] = x[i] ^ z[i];
    }

    u_int16_t R = 0;
    for (int k = 0; k < tmp.size(); ++k)
    {
        for (int i = 0; i < 64; i += 8)
        {
            R += wt8[(tmp[k] >> i) & (255)];
        }
    }
    return R;
}

u_int16_t R1(vector<uint64_t> x, vector<uint64_t> z)
{
    vector<uint64_t> tmp(x.size());
    if(x.size() != z.size())
    {
        std::cout<<"prblem\n\n";
    }
    for(size_t i = 0; i < x.size(); ++i)
    {
        tmp[i] = x[i] ^ z[i];
    }

    u_int16_t R = 0;
    for (int k = 0; k < tmp.size(); ++k)
    {
        for (int i = int(log2(tmp[k])); i >= 0; --i)
        {
            R += (tmp[k] >> i) & 1;
        }
    }
    return R;
}

u_int16_t R2(vector<uint64_t> x, vector<uint64_t> z, vector<int>& wt)
{
    vector<uint64_t> tmp(x.size());
    if(x.size() != z.size())
    {
        std::cout<<"prblem\n\n";
    }
    for(size_t i = 0; i < x.size(); ++i)
    {
        tmp[i] = x[i] ^ z[i];
    }

    u_int16_t R = 0;
    for (int k = 0; k < tmp.size(); ++k)
    {
        for (int i = 0; i < 64; i += 16)
        {
            R += wt[(tmp[k] >> i) & (65535)];
        }
    }
    return R;
}




void takeN(vector<u_int64_t> &z, int N)
{
    std::string s = "00100000111010111011101010010001000010110000010111111001000101101010101110110100100100100010001010011000101010111111100011111010000110110101000010101110011011000100101100000010011010010101110000000000010001010111111010010010011100110100100100011100000010011101010001111001101010110001101010001011000010001001001011101010011010101100110010000110011000110001010111100000010100000110111010101111010001100110101110010100001011111011010010110100111110101011111011001100011010110110010110010001010001001010100110111110100001001000011001100101100101101111001100011001010110000110111010011101110000110011010000111000101111111011011100001011011011101110001100010010011000001101111101000100101111110101011001101111000010101110000110011000111110101101100001101010101100010001011110100010001111110101011110101100101011000001100111001100101110011111110010110011100100111101010110111001001001001110001111001001011110110011111110000010010100111111010100011100001101000001011011111100011111111100111001100010110100001100110011001001110000100001110111000101010101011111101000101101110101100101100010001010111100100100001100111110101010111100000011100101111101110110010011101011001111101001001111100101100000100100010000011001110110111011011011101001100011100010000001001000000111011001110100001110001000001000100110001001100111100110110010011110101001110111110001010010101110110101111100010100010011111100010000010111001100111011101111010011011101000001110111111100010000000101001100011011100111001111011100011110001101110000100100010110111011010111110011101101100100001101101100100111100011100011100000100101000100101101010100111001110100101101111011010111101100001101000111011010111110001010000000101001010000001001100000000100100111001001011010001101100010010100010101100100110100111000010000000101000100000001111100000101010101111000111011001110110111001100110011110001101010100100011111100100101001001001001010111010010001101100011101111100010110011010001001010101001010000010011111010111010111100110111111001110110100100100000101111101111000001010111010110000";
    std::cout<<s<<'\n';
   // std::reverse(s.begin(),s.end());
    u_int64_t tmp = 0;
    for(int i = 0; i < N; ++i)
    {
        if(i % 64 == 0 && i != 0)
        {
            z.push_back(tmp);
            tmp = 0;
        }

        if(s[i] == '1')
        {
            tmp ^= ((u_int64_t)1 << (63 - i%64));
        }

    }
    if(z.size() != ceil(double(N)/double(64)))
        z.push_back(tmp);
}
// 0010000011101011101110101001000100001011000001011111100100010110 1010101110110100100100100010001010011000101010111111100011111010 0001101101010000101011100110110001001011000000100110100101011100 0000000001000101011111101001001001110011010010010001110000001001 11 01010001111001101010110001101010001011000010001001001011101010 011010101100110010000110011000110001010111100000010100000110111010101111010001100110101110010100001011111011010010110100111110101011111011001100011010110110010110010001010001001010100110111110100001001000011001100101100101101111001100011001010110000110111010011101110000110011010000111000101111111011011100001011011011101110001100010010011000001101111101000100101111110101011001101111000010101110000110011000111110101101100001101010101100010001011110100010001111110101011110101100101011000001100111001100101110011111110010110011100100111101010110111001001001001110001111001001011110110011111110000010010100111111010100011100001101000001011011111100011111111100111001100010110100001100110011001001110000100001110111000101010101011111101000101101110101100101100010001010111100100100001100111110101010111100000011100101111101110110010011101011001111101001001111100101100000100100010000011001110110111011011011101001100011100010000001001000000111011001110100001110001000001000100110001001100111100110110010011110101001110111110001010010101110110101111100010100010011111100010000010111001100111011101111010011011101000001110111111100010000000101001100011011100111001111011100011110001101110000100100010110111011010111110011101101100100001101101100100111100011100011100000100101000100101101010100111001110100101101111011010111101100001101000111011010111110001010000000101001010000001001100000000100100111001001011010001101100010010100010101100100110100111000010000000101000100000001111100000101010101111000111011001110110111001100110011110001101010100100011111100100101001001001001010111010010001101100011101111100010110011010001001010101001010000010011111010111010111100110111111001110110100100100000101111101111000001010111010110000
// 0010000011101011101110101001000100001011000001011111100100010110 1010101110110100100100100010001010011000101010111111100011111010 0001101101010000101011100110110001001011000000100110100101011100 000000000100010101111110100100 1001110011010010010001110000001001 11 01010001111001101010110001101010001011000010001001001011101010011010101100110010000110011000110001010111100000010100000110111010101111010001100110101110010100001011111011010010110100111110101011111011001100011010110110010110010001010001001010100110111110100001001000011001100101100101101111001100011001010110000110111010011101110000110011010000111000101111111011011100001011011011101110001100010010011000001101111101000100101111110101011001101111000010101110000110011000111110101101100001101010101100010001011110100010001111110101011110101100101011000001100111001100101110011111110010110011100100111101010110111001001001001110001111001001011110110011111110000010010100111111010100011100001101000001011011111100011111111100111001100010110100001100110011001001110000100001110111000101010101011111101000101101110101100101100010001010111100100100001100111110101010111100000011100101111101110110010011101011001111101001001111100101100000100100010000011001110110111011011011101001100011100010000001001000000111011001110100001110001000001000100110001001100111100110110010011110101001110111110001010010101110110101111100010100010011111100010000010111001100111011101111010011011101000001110111111100010000000101001100011011100111001111011100011110001101110000100100010110111011010111110011101101100100001101101100100111100011100011100000100101000100101101010100111001110100101101111011010111101100001101000111011010111110001010000000101001010000001001100000000100100111001001011010001101100010010100010101100100110100111000010000000101000100000001111100000101010101111000111011001110110111001100110011110001101010100100011111100100101001001001001010111010010001101100011101111100010110011010001001010101001010000010011111010111010111100110111111001110110100100100000101111101111000001010111010110000

void buildX(vector<u_int64_t> &x, const int& N, u_int64_t u)
{
    u_int64_t tmp = 0;
    u_int64_t x0 = 0;
    //std::cout<<"x0:\n";
    L1(u, x0);
    tmp ^= x0 << 63 ;
    //std::cout<<x0;
    for(int i = 1; i < N; ++i)
    {
        if(i % 64 == 0 )
        {
            //std::cout<<" ";
            x.push_back(tmp);
            tmp=0;
        }
        L1(u, x0);
        tmp ^= x0 << (63 - i%64);
        //std::cout<<x0;
    }
    //std::cout<<"\n";
    if(x.size() != ceil(double(N)/double(64)))
        x.push_back(tmp);

}

void buildY(vector<u_int64_t> &x, const int& N, u_int64_t u)
{
    u_int64_t tmp = 0;
    u_int64_t x0 = 0;
    //std::cout<<"x0:\n";
    L2(u, x0);
    tmp ^= x0 << 63 ;
    //std::cout<<x0;
    for(int i = 1; i < N; ++i)
    {
        if(i % 64 == 0 )
        {
            //std::cout<<" ";
            x.push_back(tmp);
            tmp=0;
        }
        L1(u, x0);
        tmp ^= x0 << (63 - i%64);
        //std::cout<<x0;
    }
    //std::cout<<"\n";
    if(x.size() != ceil(double(N)/double(64)))
        x.push_back(tmp);

}

void buildWt(std::vector<int>& wt)
{
    for(int i = 0; i < 65536; ++i)
    {
        int m =0;
        for(int j = 0; j < 16; ++j)
        {
            m += ((i>>j)&1);
        }
        wt.push_back(m);
    }
}



int main()
{
    u_int64_t t1 = (u_int64_t)1<<30;
    u_int64_t t2 = (u_int64_t)1<<31;
    std::vector<std::string> vec;
    int C1 = 81;
    int N1 = 258;
    int C2 = 83;
    int N2 = 265;
    int d = 1;
    vector<int> wt;
    buildWt(wt);

    vector<u_int64_t> z;

    takeN(z,N1);

    vector<u_int64_t> candidatesL1;


    #pragma omp parallel for
    for(u_int64_t i = 0; i <t1; ++i)
    {
        vector<u_int64_t> x;
        buildX(x, N1, i);
//        int r = R(x, z);
//        int r2 = R2(x,z,wt);
        int r = R1(x,z);

        //std::cout<<'\n'<<i<<" "<<r<<'\n';
        if(r<C1)
        {
            candidatesL1.push_back(i);
            //std::cout<<'\n'<<i<<" "<<r<<'\n';
            std::cout<<'\n'<<i<<" "<<candidatesL1.size()<<'\n';
        }
    }
    vector<u_int64_t> z2;
    takeN(z2,N2);


    vector<u_int64_t> candidatesL2;
    #pragma omp parallel for
    for(u_int64_t i = 0; i < t2; ++i)
    {
        vector<u_int64_t> x;
        buildY(x, N2, i);
        int r = R(x, z);

        //std::cout<<'\n'<<i<<" "<<r<<'\n';
        if(r<C2)
        {
            candidatesL2.push_back(i);
            //std::cout<<'\n'<<i<<" "<<r<<'\n';
            std::cout<<'\n'<<i<<" "<<candidatesL2.size()<<'\n';
        }
    }





    std::cout<<"done";
}

